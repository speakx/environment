package mmapcache

import (
	"fmt"
	"os"
	"path/filepath"
	"sync/atomic"
	"testing"
)

func TestMmapCache(t *testing.T) {
	dir, _ := filepath.Abs(filepath.Dir(os.Args[0]))
	cachefile := fmt.Sprintf("%v/0.dat", dir)
	t.Logf("cachefile:%v", cachefile)

	// mmap文件大小
	tSize := 256

	// 测试构建mmap文件
	template := createMMapTemplate(tSize)
	err := createMMapFile(cachefile, template)
	if nil != err {
		t.Errorf("createMMapFile err:%v", err)
	}
	fi, err := os.Stat(cachefile)
	if nil != err {
		t.Errorf("createMMapFile err:%v", err)
	}
	if int64(tSize) != fi.Size() {
		t.Errorf("createMMapFile err size:%v != fi.size:%v", tSize, fi.Size())
	}
	t.Logf("createMMapFile is ok")

	// 测试映射mmap文件到内存
	mmapCache, err := newMMapCache(cachefile)
	if nil != err {
		t.Errorf("newMMapCache err:%v", err)
	}
	buffer := mmapCache.GetBuffer()
	if int64(len(buffer)) < fi.Size() {
		t.Errorf("newMMapCache err mmap.buffer.len:%v != file.size:%v", len(buffer), fi.Size())
	}
	t.Logf("newMMapCache is ok")

	// 测试write方法
	writeByte := []byte("Hello")
	n, err := mmapCache.Write(writeByte)
	if nil != err {
		t.Errorf("mmapCache.Write err:%v", err)
	}
	if n != len(writeByte) {
		t.Errorf("mmapCache.Write %v -> n:%v", writeByte, n)
	}
	t.Logf("mmapCache.Write is ok")

	// 测试write
	writeBuf := mmapCache.GetWriteData()
	if string(writeBuf) != string(writeBuf) {
		t.Errorf("mmapCache.Write err, file.val:%v input.val:%v", string(writeBuf), string(writeBuf))
	}
	t.Logf("mmapCache.GetWriteData is ok")

	// 测试write后的文件缓存中，头部4字节的有效数据长度是否正确
	if mmapCache.safeGetWritePos() != n {
		t.Errorf("mmapCache.Write err, file.writeHead:%v != n:%v", mmapCache.safeGetWritePos(), n)
	}
	t.Logf("mmapCache.safeGetWritePos is ok")

	// 测试mmap文件的recycle
	mmapCache.recycle(template)
	for index := 0; index < 4; index++ {
		if buffer[index] != 0 {
			t.Errorf("mmapCache.recycle error n:%v buf:%v", index, buffer)
		}
	}
	t.Logf("mmapCache.recycle is ok")

	// 删除临时文件
	mmapCache.close(true)
	fi, _ = os.Stat(cachefile)
	if nil != fi {
		t.Errorf("Remove mmapCache file failed. file still exist dir:%v", cachefile)
	}
	t.Logf("mmapCache.close is ok")
}

var benchMMapCacheSize = 1024 * 1024 * 4
var benchMMapIndex int32 = -1

func TestMmapCachePool(t *testing.T) {
	dir, _ := filepath.Abs(filepath.Dir(os.Args[0]))
	MMapCachePoolInit(dir, benchMMapCacheSize, 50, func(error) {})
}

func Benchmark_mmapcache_create(b *testing.B) {
	tSize := benchMMapCacheSize
	template := createMMapTemplate(tSize)

	dir, _ := filepath.Abs(filepath.Dir(os.Args[0]))
	for i := 0; i < b.N; i++ {
		cachefile := fmt.Sprintf("%v/bench_mmap_%v.dat", dir, atomic.AddInt32(&benchMMapIndex, 1))
		createMMapFile(cachefile, template)
	}
	b.Logf("mmapcache create curidex:%v count:%v total.mmap.cache.size:%v MB", benchMMapIndex, b.N, benchMMapIndex*10)
}

func Benchmark_mmapcache_write(b *testing.B) {
	b.Logf("mmapcache mmap write size:%v MB", b.N)
	writeByte := make([]byte, 1024*1024)
	mmapCache := DefPoolMMapCache.Alloc()
	for i := 0; i < b.N; i++ {
		if mmapCache.GetFreeDataLen() < len(writeByte) {
			mmapCache.Release()
			mmapCache = DefPoolMMapCache.Alloc()
		}
		mmapCache.Write(writeByte, nil)
	}
}

var benchFileIndex int = 0

func Benchmark_file_write(b *testing.B) {
	dir, _ := filepath.Abs(filepath.Dir(os.Args[0]))
	cachefile := fmt.Sprintf("%v/bench_file_%v.dat", dir, benchFileIndex)
	b.Logf("mmapcache file write size:%v MB", b.N)
	benchFileIndex++

	// 构建一个待写入的数据
	writeByte := make([]byte, 1024*1024)

	// 构建一个mmapcache
	// 每次写入1 MB数据
	f, _ := os.OpenFile(cachefile, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0)
	defer func() {
		f.Close()
		os.Remove(cachefile)
	}()

	for i := 0; i < b.N; i++ {
		f.Write(writeByte)
	}
}
